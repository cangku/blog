---
title: 深拷贝和浅拷贝
date: 2019-04-02 10:00:00
tags:
    - 非学前端
    - 深拷贝
    - 浅拷贝

categories:
    - 学习
---

本文直接上手示例，对于JS数据类型，需要注意的是 Array 并不是数据类型之一（[参考类数组对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays)）。  
还需要理解什么是基本类型，什么是引用类型，与之发散的概念应该就是值传递和引用传递。  
<!-- more -->

### 浅拷贝
```javascript
{
    const obj = {
        a: 1, // Number
        b: 'b', // String
        c: null, // Null
        d: undefined, // Undefined
        e: true, // Boolean
        f: Symbol('f'), // Symbol
        g: [1, 'b'],
        h: {a: 1, b: 'b'}, // Object
        i: function(a) { console.log(this) }
    }

    function shallowCopy(orig) {
        let dist = {};
        for(let prop in orig) {
            if (orig.hasOwnProperty(prop)) {
                dist[prop] = orig[prop];
            }
        }
        return dist;
    }
    
    const obj1 = obj;
    const obj2 = shallowCopy(obj1);
    const obj3 = JSON.parse(JSON.stringify(obj1));

    obj1.a = 2;
    obj1.b = 3;
    obj1.c = 4;
    obj1.d = 5;
    obj1.e = 6;
    obj1.f = 7;
    obj1.g[0] = 'a';
    obj1.h['a'] = 'a';
    obj1.i = function() { console.log('i function') };

    console.log(obj, obj1, obj2, obj3);

    // obj 与 obj1 是引用类型，obj 与 obj1 指向相同的堆内存中。  
    // obj2 是通过通过拷贝函数传入参数 obj1 获得，内部初始化了一个目标对内存，并将存放在 obj1 上的值拷贝一份给 obj2 。对于基本类型我们是直接将值赋值给了新的对象属性，对于 obj1 中的引用类型，这个适合赋值给新的对象属性的只是一个引用地址。所以修改 obj1 中的属性值是引用类型时会同时改变多个对象。但是其中不变的有基本类型和函数  
    // obj3 先转换为字符串，序列化化为字符串的过程中会丢失 undefined Symbol Function。反序列化以后对于原 Obj1 中的应用类型属性值不存在引用关系了。如果存在 new Date()，正常获得的应该是 `toString()`，实际获得的是 `toISOString()`  
    // 还有其他方案 MessageChannel => Web Worker  Notification => new Notification() History => history.replaceState
}

```
### 深拷贝
```javaScript
// 在浅拷贝的基础上怎么实现深拷贝，浅拷贝问题在于遍历的时候是直接赋值，并没有判断类型，如果属性值是引用类型我们需要继续遍历属性值最后再赋值，这个过程就完成了深拷贝
```