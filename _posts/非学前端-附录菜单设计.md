---
title: 菜单设计
date: 2019-03-04 10:00:00
tags:
    - 非学前端
    - Tree

categories:
    - 学习
---

## 目录
- 内存管理 Memory Management
- 什么是堆栈队列 Heap Stack Quene
    * 栈
    * 堆
    * 队列
- 什么是运行时
- javascript 数据结构
- 内存地址与内存空间
- 扁平化菜单设计
- 树状结构菜单生成

## 内存管理
[Memory Management](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)
Javascript 创建变量时分配内存，不使用时会自动被垃圾回收。  
* 引用计数
* 标记清除


## 什么是堆栈队列

### 栈
栈数据结构的访问规则是 LIFO（Last-In-First-Out）后进先出
```javascript
let colors = new Array();
let len = colors.push('red', 'orange');
console.log(len); // 2
len = colors.push('yellow');
console.log(len); // 3
const item = colors.pop();
console.log(item, colors.length); // yellow 2
```

### 堆
```javascript

```

### 队列
堆数据结构的访问规则是 FIFO（First-In-First-Out）先进先出
```javascript
// example 1
let colors = new Array();
let len = colors.push('red', 'orange');
console.log(len); // 2
len = colors.push('yellow');
console.log(len); // 3
const item = colors.shift();
console.log(item, colors.length); // red 2

// example 2
let colors = new Array();
let len = colors.push('red', 'orange');
console.log(len); // 2
len = colors.unshift('yellow');
console.log(len); // 3
const item = colors.pop();
console.log(item, colors.length); // orange 2

// example 3 (Proxy)

const Stack = function() {
    return new Proxy([], {
        get(target, name) {
            return target[name];
        }
    })
}

// TODO: 扩展 Proxy 的应用 Cookie Storage Fetch Ajax
// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy
// https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie
```

## 运行时

```javascript
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start')
setTimeout(function () {
    console.log('setTimeout')
}, 0)
async1();
new Promise(function (resolve) {
    console.log('promise1')
    resolve();
}).then(function () {
    console.log('promise2')
})
console.log('script end')
```
这道题涉及 setTimeout Promise Async Await 运行时堆栈和 microtasks macrotasks

## javascript 的数据类型和数据结构
[javascript 的数据类型和数据结构](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures) 中有很详细的描述。  

### 动态类型语言
JavaScript 是弱语言也叫着动态语言，不需要提前申明变量类型，在运行过程中会自动确定类型。  
```javascript
let a = 123;
a = 'abc';
a = false;
console.log(a); // false
```

```typescript
// 类型检测
let a: Number = 123;
a = 'abc'; // Error: Type '"abc"' is not assignable to type 'Number'.
```

### 数据类型
ECMAScript 定义了 7 种数据类型
* 基本类型
    * Null
    * Undefined
    * Boolean
    * String
    * Number
    * Symbol
* 引用类型
    * Object

**类型判断**
typeof 可以判断基本类型，但是 typeof null 返回的是 object，typeof function() {} 返回的是 function。  
instanceof 判断实例与构造函数的关系。  
```javascript
cosnt boolean = variable instanceof constructor;
```

**不同点**  

1. 只能给引用类型动态添加属性
    ```javascript
    // example 1
    let person = new Object();
    person.name = 'unofficial';
    console.log(person.name); // unofficial

    // example 2
    let name = 'unofficial';
    name.age = 1; // 这里name判断为基本类型，会执行一个 new String(name) 创建一个临时引用类型，然后添加一个 age 属性，所以实际赋值过程中不会报错
    console.log(name.age); // undefined

    // example 3
    let name = new String('unofficial');
    name.age = 1;
    console.log(name.age); // 1
    ```
2. 基本类型复制的是值，会在变量对象上创建一个新的值；引用类型复制的是引用关系
    ```javascript
    // example 1
    let a = 1;
    let b = a;
    a = a + 1;
    console.log(a, b); // 2, 1

    // example 2
    let person = {};
    let person1 = person; // 复制引用类型的时候复制的是引用关系
    person.name = 'unofficial';
    console.log(person.name, person1.name); // unofficial, unofficial
    // 后续继续深入学习 深拷贝和浅拷贝 =>>> 参考非学前端-附录深拷贝和浅拷贝
    ```

3. 函数中传递参数都是按照都是按照值传递
    ```javascript
    // example 1
    let a = 1;
    function foo(a) {
        // foo 函数被调用的时候会创建一个栈帧，在里面会有一个局部对象 arguments 。a 会被赋值为一个属性值，类似基本类型值的复制

        return ++a;
    }
    console.log(a, foo(a), a); // 1, 2, 1

    // example 2
    let a = 1;
    function foo() {
        // 当前作用域找不到对于 a 的定义，会继续向父级作用域查找 a。找到后自加，修改的是父级作用域的 a。
        return ++a;
    }
    console.log(a, foo(), a); // 1, 2, 2

    // example 3 【***】
    let a = {
        age: 1
    };
    function foo(a) {
        // 这里的 a 被赋值给了局部对象 arguments(还是说 arguments[0] 赋值给 a ? )，对象的赋值其实只是引用关系的赋值，修改值会直接修改原对象中值。
        console.log(arguments[0] === a); // true

        // 这里因为还是引用类型的关系，自加以后会影响到原对象
        a.age++;

        // 🦐 🥚 让它快速成年，这里因为 a 在栈帧中做为局部变量以后，重新为局部变量 a 分配了变量，改变了引用地址，指向了新的内存空间
        a = {
            age: 18
        };

        console.log(arguments[0] === a); // true
        return ++a.age;
    }
    console.log(a.age, foo(a), a.age); // 1, 19, 2
    ```
## 扁平化菜单设计
数据的存储或者修改尽量只涉及到当前数据。  

### 扁平数据
在业余项目中我的《[GraphQL学习过程应该是这样的](https://blog.unofficial.cn/2019/02/18/非学前端-附录graphql/)》，其中菜单部分数据在 mongodb 中以扁平化的形式存放数据，查询出来的数据生成树状结构返回给前端。  
添加一个新的菜单项目我们提交的数据例如下面这样。  
```json
{
    "name": "菜单名称"
}
```
服务端拿到数据以后检测数据中是否存在 id 、pid ，新增 id 服务端按照规则生成或者数据库自增。pid 为上级菜单的 id，不存在默认为空存放进入数据库中。  
```js
[
    ...
    ,
    {
        "id": 1009,
        "name": "菜单名称",
        "pid": null
    }
]
```
给菜单名称添加一个子菜单名称拿到的数据应该就是  
```js
[
    ...
    ,
    {
        "id": 1009,
        "name": "菜单名称",
        "pid": null
    }
    ,
    {
        "id": 1010,
        "name": "子菜单名称",
        "pid": 1009
    }
]
```

### 树结构
把上面的数据需要处理成树结构，为每一项添加一个 children ，期望得到如下结果。  
```js
[
    ...
    ,
    {
        "id": 1009,
        "name": "菜单名称",
        "pid": null,
        "children": [
            {
                "id": 1010,
                "name": "子菜单名称",
                "pid": 1009,
                "children": []
            }
        ]
    }
]
```

## 树状结构菜单生成
了解了菜单的扁平设计以及明确了我们需要得到的树状结构数据，如何才能生成这样的树状结构呢？  
这个过程需要遍历数据库中查询出来的数组 menus ，存入新的数组中 newMenus 。newMenus 中的数据实际只是存放的内存地址，实际指向的内存空间和 menus 是相同的。  

```javascript
const menus = [
    {
        name: '菜单名称'
    }
];

const menu = menus[0];
menus[0].name = '菜单';
console.log(menu.name); // 菜单
```

遍历 menus 的过程中如果 pid 为 null，我们把数据存入 newMenus，如果 pid 不为空，我们找到 id 等于 pid 的数据给它添加上 children 。  
为了方便在遍历的过程中轻松找到 id 等于 pid 的数据，我们以 id 为 key 产生一个新的对象。  

```javascript
let map = {};
menus.forEach(item => {
    const key = item.id; // 以 id 为 key
    map[key] = item;
})
```

遍历 menus 数组获得新的数组 newMenus  

```javascript
let newMenus = [];
menus.forEach(item => {
    if (item.pid) {
        const key = item.pid; // 找到 id 等于 pid 的数据
        // 因为 children 是新增的，可能存在，可能不存在
        (map[key].children || (map[key].children = [])).push(item);
    } else {
        newMenus.push(item);
    }
})
```

menus map newMenus 他们其实是指向的相同内存空间。例如我们修改一下 menus 中的 name ，map 、 newMenus 中对于数据的 name 也会被修改。  

### 深浅拷贝

### 


### 参考资料

http://blog.leapoahead.com/2015/09/15/js-closure/
https://dmitryfrank.com/articles/js_closures?utm_source=javascriptweekly&utm_medium=email
https://developer.mozilla.org/zh-CN/docs/Web/
https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weeklyJavaScript/EventLoop
https://www.youtube.com/watch?v=8aGhZQkoFbQ